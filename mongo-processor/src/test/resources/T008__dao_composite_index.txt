package io.bkbn.lerasium.generated.persistence.dao

import com.mongodb.client.MongoCollection
import com.mongodb.client.MongoDatabase
import io.bkbn.lerasium.core.dao.Dao
import io.bkbn.lerasium.core.model.CountResponse
import io.bkbn.lerasium.generated.models.UserCreateRequest
import io.bkbn.lerasium.generated.models.UserResponse
import io.bkbn.lerasium.generated.models.UserUpdateRequest
import io.bkbn.lerasium.generated.persistence.entity.UserEntity
import java.util.UUID
import kotlin.Int
import kotlin.Unit
import kotlin.collections.List
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import org.litote.kmongo.deleteOneById
import org.litote.kmongo.ensureIndex
import org.litote.kmongo.findOneById
import org.litote.kmongo.getCollection
import org.litote.kmongo.save

public class UserDao(
  db: MongoDatabase,
) : Dao<UserEntity, UserResponse, UserCreateRequest, UserUpdateRequest> {
  private val collection: MongoCollection<UserEntity> = db.getCollection()

  init {
    collection.ensureIndex(UserEntity::name, UserEntity::favoriteFood)
  }

  public override fun create(requests: List<UserCreateRequest>): List<UserResponse> {
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    val entities = requests.map { request ->
      val entity = UserEntity(
        id = UUID.randomUUID(),
        createdAt = now,
        updatedAt = now,
        name = request.name,
        favoriteFood = request.favoriteFood,
      )
      collection.save(entity)
      entity
    }
    return entities.map { it.toResponse() }
  }

  public override fun read(id: UUID): UserResponse {
    val entity = collection.findOneById(id) ?: error("""Unable to get entity with id: $id""")
    return entity.toResponse()
  }

  public override fun update(id: UUID, request: UserUpdateRequest): UserResponse {
    val entity = collection.findOneById(id) ?: error("""Unable to get entity with id: $id""")
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    request.name?.let {
      entity.name = it
    }
    request.favoriteFood?.let {
      entity.favoriteFood = it
    }
    entity.updatedAt = now
    collection.save(entity)
    return entity.toResponse()
  }

  public override fun delete(id: UUID): Unit {
    collection.deleteOneById(id)
  }

  public override fun countAll(): CountResponse {
    val count = collection.countDocuments()
    return CountResponse(count)
  }

  public override fun getAll(chunk: Int, offset: Int): List<UserResponse> {
    val entities = collection.find().skip(chunk * offset).limit(chunk)
    return entities.toList().map { entity ->
      entity.toResponse()
    }
  }
}
