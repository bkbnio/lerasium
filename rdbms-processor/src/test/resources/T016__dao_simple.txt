package io.bkbn.lerasium.generated.persistence.dao

import io.bkbn.lerasium.core.dao.Dao
import io.bkbn.lerasium.core.model.CountResponse
import io.bkbn.lerasium.generated.models.UserCreateRequest
import io.bkbn.lerasium.generated.models.UserResponse
import io.bkbn.lerasium.generated.models.UserUpdateRequest
import io.bkbn.lerasium.generated.persistence.entity.UserEntity
import java.util.UUID
import kotlin.Int
import kotlin.collections.List
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import org.jetbrains.exposed.sql.transactions.transaction

public object UserDao : Dao<UserEntity, UserResponse, UserCreateRequest, UserUpdateRequest> {
  public override fun create(requests: List<UserCreateRequest>): List<UserResponse> = transaction {
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    val entities = requests.map { request ->
      transaction {
        UserEntity.new {
          name = request.name
          createdAt = now
          updatedAt = now
        }
      }
    }
    entities.map { it.toResponse() }
  }

  public override fun read(id: UUID): UserResponse = transaction {
    val entity = UserEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    entity.toResponse()
  }

  public override fun update(id: UUID, request: UserUpdateRequest): UserResponse = transaction {
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    val entity = UserEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    request.name?.let {
      entity.name = it
    }
    entity.updatedAt = now
    entity.toResponse()
  }

  public override fun delete(id: UUID) = transaction {
    val entity = UserEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    entity.delete()
  }

  public override fun countAll(): CountResponse = transaction {
    val count = UserEntity.count()
    CountResponse(count)
  }

  public override fun getAll(chunk: Int, offset: Int): List<UserResponse> = transaction {
    val entities = UserEntity.all().limit(chunk, offset.toLong())
    entities.map { entity ->
      entity.toResponse()
    }
  }
}
