package io.bkbn.lerasium.generated.persistence.dao

import io.bkbn.lerasium.core.dao.Dao
import io.bkbn.lerasium.core.model.CountResponse
import io.bkbn.lerasium.generated.models.CountryCreateRequest
import io.bkbn.lerasium.generated.models.CountryResponse
import io.bkbn.lerasium.generated.models.CountryUpdateRequest
import io.bkbn.lerasium.generated.models.UserResponse
import io.bkbn.lerasium.generated.persistence.entity.CountryEntity
import java.util.UUID
import kotlin.Int
import kotlin.collections.List
import kotlinx.datetime.Clock
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import org.jetbrains.exposed.sql.transactions.transaction

public object CountryDao :
    Dao<CountryEntity, CountryResponse, CountryCreateRequest, CountryUpdateRequest> {
  public override fun create(requests: List<CountryCreateRequest>): List<CountryResponse> =
      transaction {
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    val entities = requests.map { request ->
      transaction {
        CountryEntity.new {
          name = request.name
          createdAt = now
          updatedAt = now
        }
      }
    }
    entities.map { it.toResponse() }
  }

  public override fun read(id: UUID): CountryResponse = transaction {
    val entity = CountryEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    entity.toResponse()
  }

  public override fun update(id: UUID, request: CountryUpdateRequest): CountryResponse =
      transaction {
    val now = Clock.System.now().toLocalDateTime(TimeZone.UTC)
    val entity = CountryEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    request.name?.let {
      entity.name = it
    }
    entity.updatedAt = now
    entity.toResponse()
  }

  public override fun delete(id: UUID) = transaction {
    val entity = CountryEntity.findById(id) ?: error("""Unable to get entity with id: $id""")
    entity.delete()
  }

  public override fun countAll(): CountResponse = transaction {
    val count = CountryEntity.count()
    CountResponse(count)
  }

  public override fun getAll(chunk: Int, offset: Int): List<CountryResponse> = transaction {
    val entities = CountryEntity.all().limit(chunk, offset.toLong())
    entities.map { entity ->
      entity.toResponse()
    }
  }

  public fun getAllUsers(
    id: UUID,
    chunk: Int,
    offset: Int,
  ): List<UserResponse> = transaction {
    val entity = CountryEntity[id]
    entity.users.limit(chunk, offset.toLong()).toList().map { it.toResponse() }
  }
}
