package io.bkbn.lerasium.generated.persistence.repository

import io.bkbn.lerasium.generated.api.models.UserModels.Create
import io.bkbn.lerasium.generated.api.models.UserModels.Update
import io.bkbn.lerasium.generated.domain.UserDomain
import io.bkbn.lerasium.generated.persistence.config.PostgresConfig
import io.bkbn.lerasium.generated.persistence.table.UserTable
import io.bkbn.lerasium.generated.persistence.table._UserTable
import io.bkbn.lerasium.generated.persistence.table.user
import java.util.UUID
import org.komapper.core.dsl.Meta
import org.komapper.core.dsl.QueryDsl
import org.komapper.core.dsl.query.andThen
import org.komapper.core.dsl.query.single
import org.komapper.r2dbc.R2dbcDatabase

public object UserRepository {
  private val db: R2dbcDatabase = PostgresConfig.database

  private val resource: _UserTable = Meta.user

  public suspend fun create(request: Create): UserDomain = db.withTransaction {
    val result = db.runQuery {
      QueryDsl.insert(resource).single(
        UserTable(
          name = request.name,
          count = request.count,
          isFact = request.isFact,
          size = request.size,
          pointyNum = request.pointyNum,
        )
      )
    }
    result.to()
  }

  public suspend fun read(id: UUID): UserDomain = db.withTransaction {
    val result = db.runQuery {
      val query = QueryDsl.from(resource).where {
        resource.id eq id
      }
      query.single()
    }
    result.to()
  }

  public suspend fun update(id: UUID, request: Update): UserDomain = db.withTransaction {
    val result = db.runQuery {
      QueryDsl.update(resource)
        .set {
          request.name?.let { v -> it.name to v }
          request.count?.let { v -> it.count to v }
          request.isFact?.let { v -> it.isFact to v }
          request.size?.let { v -> it.size to v }
          request.pointyNum?.let { v -> it.pointyNum to v }
        }
        .where {
          resource.id eq id
        }
        .andThen(QueryDsl.from(resource).where { resource.id eq id }.single())
    }
    result.to()
  }

  public suspend fun delete(id: UUID) = db.withTransaction {
    db.runQuery {
      QueryDsl.delete(resource).where { resource.id eq id }
    }
  }
}
